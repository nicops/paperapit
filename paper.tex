%======================================================================
% DVCS paper!
%======================================================================
\documentclass[%
	%draft,
	%submission,
	%compressed,
	final,
	%
	%technote,
	%internal,
	%submitted,
	%inpress,
	%reprint,
	%
	%titlepage,
	notitlepage,
	%anonymous,
	narroweqnarray,
	inline,
	twoside,
        %invited,
	]{ieee}

\newcommand{\latexiie}{\LaTeX2{\Large$_\varepsilon$}}

%\usepackage{ieeetsp}	% if you want the "trans. sig. pro." style
%\usepackage{ieeetc}	% if you want the "trans. comp." style
%\usepackage{ieeeimtc}	% if you want the IMTC conference style

% Use the `endfloat' package to move figures and tables to the end
% of the paper. Useful for `submission' mode.
%\usepackage {endfloat}

% Use the `times' package to use Helvetica and Times-Roman fonts
% instead of the standard Computer Modern fonts. Useful for the 
% IEEE Computer Society transactions.
%\usepackage{times}
% (Note: If you have the commercial package `mathtime,' (from 
% y&y (http://www.yandy.com), it is much better, but the `times' 
% package works too). So, if you have it...
%\usepackage {mathtime}

% for any plug-in code... insert it here. For example, the CDC style...
%\usepackage{ieeecdc}

\begin{document}

%----------------------------------------------------------------------
% Title Information, Abstract and Keywords
%----------------------------------------------------------------------
\title[Distributed Version Control Systems]{%
       Distributed Version Control Systems}

% format author this way for journal articles.
% MAKE SURE THERE ARE NO SPACES BEFORE A \member OR \authorinfo
% COMMAND (this also means `don't break the line before these
% commands).
\author[GRUPOAPIT]{Damian Alonso,
\and{} Bruno Bonnano,
\and{} Nicol\'{a}s Calligaro
\and{}and Nicol\'{a}s Perez Santoro
}

\journal{Universidad Tecnol\'{o}gica Nacional, Facultad Regional Buenos Aires}
%\titletext{, VOL.\ 46, NO.\ 6, DECEMBER\ 1997}
%\ieeecopyright{0018--9456/97\$10.00 \copyright\ 1997 IEEE}
%\lognumber{xxxxxxx}
%\pubitemident{S 0018--9456(97)09426--6}
%\loginfo{Manuscript received September 27, 1997.}
\firstpage{1}

%\confplacedate{Buenos Aires, Argentina, April 18, 2010}

\maketitle               

\begin{abstract} 
Abstract to be done
\end{abstract}

\begin{keywords}
to be done
\end{keywords}

%----------------------------------------------------------------------
% SECTION I: Introduction
%----------------------------------------------------------------------
\section{Introduction}

%It is given that, in these times, modern software projects need a tool to 
%automatically track changes made in the source files, called Version Control Systems (VCS). 

\PARstart Version Control Systems (VCS) usually track the whole history of the
source code in a central server that everyone that can access. This 
central server contains all the changes and branches of the code and 
the users that can read the versions or commit changes have to connect 
to this repository. The most popular today example of this approach is SVN, which is a 
widely used VCS.

Distributed Version Control Systems (DVCS) are a modern way of managing
revisions of software that do not have a centralized server, for this reason 
they are also called De-centralized Version Control Systems. Everybody has a 
copy of the full repository with all changes made in the history.

The concept of distributed repositories came up first on the commercial product 
Sun TeamWare (\emph{good citation needed}), designed by Larry McVoy who later went 
on to design BitKeeper, another commercial VCS which expanded on those ideas. 
BitKeeper was used from 2002 to 2005 to manage the Linux kernel source until 
the license to use BitKeeper was finished. 
To replace the use of BitKeeper in the Linux kernel, two projects started, Git (by
Linus Torvalds \cite{linusgit} and 
Mercurial, both now mature DVCS. Other open source DVCS in use today are Bazaar, 
developed by Canonical Ltd. and used to maintain the Ubuntu codebase, and Darcs, based on 
the idea of tracking only patches and not versions.

%Vamos a contar cuando surgió esta tecnología y sus principales 
%exponentes en la actualidad. Vamos a basarnos en GIT pero hay muchas 
%similitudes con otros sistemas de versionado distribuidos como Mercurial. 
%Un poco se contará las diferencias fundamentales entre las herramientas de 
%versionado centralizadas y distribuidas, simplemente nombrando las diferencias 
%pero no explicándolas. 

We're going to do a comparison between centralized and decentralized control version systems,
highlighting the differences and advantages and disadvantages of both approachs in various 
contexts, both on a conceptual and practical level. In this paper we'll base our explanations 
on Git but there are no big differences between 
most of these DVCS, especially between Git and Mercurial that are largely similar, with 
most commands having the same names in both tools.

%La idea del paper sería contar las ventajas que puede 
%tener este esquema dentro de un ambiente enterprise de código cerrado, en contraste 
%a un ambiente open source donde el esquema distribuido tiene incluso más sentido.

%Ejemplo de cita \cite{linusgit} 


%----------------------------------------------------------------------
% SECTION II: Architecture
%----------------------------------------------------------------------
\section{Architecture}

In a DVCS like Git, everybody has the full repository in their hard drives.
Since there is no central server, all the operations on the repository are done 
offline. This means that actions like commiting do not depend on having a 
network connection, since commits are made on your repository.

Changes can thus be shared between everyone passing changes between repositories, 
without the need of making those changes in a central repository.

% Explicaremos el principio de funcionamiento de la herramienta distribuida 
% y sus principales objetivos, contrastando el flujo de trabajo con el de un 
% sistema de control de versiones centralizado. Básicamente que cada uno tiene 
% su propio repositorio, que las versiones pueden ser infinitas (por más que 
% haya una(s) maestra(s)), que se puede trabajar offline, etc.

% -habria que agregar una imagen de muetsra

\subsection{More Atomical Commits}

In a centralized VCS, most of the time commits aren't done until you are sure that 
the change is well written and can be actually shared to everybody else, since the 
commit is going to be shared as soon as it's done. In a DVCS the nature of the commits 
is different, since commits are made in the local repository only. Therefore, they can be more atomic, 
because commits aren't huge changesets but can be logical, coherent and smaller changes. 

Many little commits, if needed, can be grouped as a bigger, conceptual commit.
To do this in a centralized VCS, one would have to create a new branch of the source code, 
and then merge the branch, but creating and merging branches all the time is 
not effortless, and branches are seen by everybody that can access the repository, 
so this is not always done.
Doing logical commits allows you to do apply a technique called ``cherry-picking'', 
which consists of ``picking'' what changes you want to use in a version, and build 
a new version containing only those changes. This way the revision tree is seen as a 
series of \emph{changesets} or \emph{patches} instead of just a series of static versions
(this also makes commits easier).


%En el sistema distribuido, hay una diferencia conceptual con los sistemas 
%centralizados acerca de la naturaleza de un commit. Se tiende a hacer commits
%más atómicos y lógicos ya que el commit se hace en el repositorio propio, 
%entonces no hay preocupaciones como romper el build.

\subsection{Tagging and Branching}

%En un sistema distribuido, tener muchísimos branches es sencillo, de hecho 
%es más que sencillo, es "natural". Lo que permite un sistema distribuido es 
%no solo tener branches baratos sino también simplificar los merges. 

Centralized VCS's like Subversion makes certain copies through history called tags. 
But on Git we have more tools, one of them is that we can have an arbitrary 
description attached in the tag, in fact, you can store the whole release announcements here. 
Moreover, as with the commit, is stored the identity of who made the tag and this identity 
can be verified if we add a cryptographically PGP sign to the tag.

\subsection{Merging}

Merge on Git between branches is greatly improved over, say, SVN, because all the history of 
both branches is preserved over the merges.
When we make a merge we have two scenarios:
Fast-forward merge: we refer to this when the changes only was made on only one of the branches,
they are simply replayed on the other branch.
Three-way merge: When changes exists on both branches, they are merged and git will report any 
conflict and let you resolve them. 


\subsection{Pushing and pulling}

% comentario via nps: cambié ``co-worker'' por ``peer'' porque es más neutral
When we want to share our work with the rest of the team we have two basic concepts, 
\emph{push} and \emph{pull}.
Push refers to taking all my changes and add them to the repository of another peer. 
But in practice we don't do this becouse we shouldn't make a push on a peer working copy, 
instead it, we push in a ``central repository'' where all the team make their pushes too, 
this logic is similar to traditional VCS, but we need to keep in mind that we could have a 
lot of ``central repositories'' for different parts of our project.
Pull is a composite action of ``fetch'' and ``merge'', fetching takes the changes from selected 
repository of a peer and copies them to a local repository, and 
then those changes are merged with the sourcecode of my local repository.
In the same way, another peer can pull on my working copy and get my code and 
changes without any problem.

If you work against a central repository, pulling and pushing do look very much like
the idea of checking out and checking in, but that's the only way of working in a centralized VCS.
In a DVCS, since every repository is a peer to each other, anyone can share their repository in 
read-only mode (via ssh, http, or just sharing the directory) to let other people pull from them. 


%Estos dos conceptos son distintos al check in / check out centralizado, 
%consisten en el envío o recepción de commits entre dos repositorios. Aquí 
%explicaremos un poco en que consisten y cuando hay que usar uno u otro.

%----------------------------------------------------------------------
% SECTION III: Should I use it in my project?
%----------------------------------------------------------------------
\section{Should I use it in my project?}

As mentioned before, this tool allows for differents workflows that just weren't 
possible before.

Changes can be just shared between peers, without needing to access the central 
repository. Branches can be created instantly, and merging them is easier since 
the whole history of changesets is preserved instead of just taking the diff of 
the versions.

Push and pull are much more versatile than checking in and out, since you can push 
changes into many repositories and pull from many others, not just a central one.
In fact, there is no need to push at all:
everyone could be just pulling changes from each other. For example, two co-workers could work 
in a feature, pulling from each other, then let a third one fetch them and do a code review, and then 
discard it or merge it. A fourth could fetch all reviewed changes into a test version, to do an 
acceptance test, and then merge the changes into a final version.

%Explicar los casos donde resulta interesante aplicar esta herramienta. 
%También la idea es mostrar configuraciones posibles para la empresa donde 
%se vea la forma de hacer cosas que con un sistema no distribuido no sería 
%posible, o como es posible hacer lo mismo que se podía hacer con svn 
%(usando un repositorio que tenga el branch principal), de manera que 
%no te limita.

%----------------------------------------------------------------------
% SECTION IV: Then, why should I use it in my project?
%----------------------------------------------------------------------
\section{Then, why should I use it in my project?}
Does everybody need these features? Speed, offline working, 
and easyness of branching/merging are nice features even if you work simply pulling 
and pushing changes against a central repository and not every peer out there. In some 
projects and with some tools, the advantage of going distributed may not be clear. 
For starters, in many closed source projects there is no need nor desire to have anything
other than centralized repositories, and while you can use a DVCS with a centralized
repository, there may not be enough to gain to balance the cost of changing. Distributed 
versioning \emph{is} more complex, and there is a ``conceptual overhead'' in the usage 
of it, even if most of the time you can ignore most features and use just what you need 
(even for one person proyects, Git and Mercurial may be easier to use than SVN).
Centralized VCS also have their advantages, you don't need to have the whole history in your 
personal repository so you can save space, for example in Perforce you can check out only a part of the 
repository\cite{perforceclientspec} while in Git repositories can't handle millions of file 
without getting a performance hit on some operations\cite{linusgit}.

Another issue with these systems is that the tool support and various plugins just isn't as 
mature as systems like SVN, which are much more mature in that regard. Git, in particular, is 
biased on Linux and doesn't really work out of the box in Windows, but works with Cygwin. 
Mercurial is much more portable, but some tools are also incomplete, like hg-subversion (a tool 
to interoperate with svn). Git has git-svn which allows to push and pull from svn repositories, 
easing transitions.

%Si mi proyecto es apto para aplicar la herramienta por qué debería utilizarla en 
%vez de utilizar CVS/SVN/otros, mostrando los costos y ventajas y desventajas,
% siempre desde el punto de vista "closed source" (debatible).


%----------------------------------------------------------------------
% SECTION VII: Conclusions
%----------------------------------------------------------------------
\section{Conclusion}

\emph{to be done}

%----------------------------------------------------------------------


\begin{thebibliography}{1}

% \bibitem{lamport}
% Leslie Lamport,
% \newblock {\em A Document Preparation System: {\LaTeX} User's Guide and
%   Reference Manual},
% \newblock Addison-Wesley, Reading, MA, 2nd edition, 1994.
% \newblock Be sure to get the updated version for \latexiie!
% 
% \bibitem{goossens}
% Michel Goossens, Frank Mittelbach, and Alexander Samarin,
% \newblock {\em The {\LaTeX} Companion},
% \newblock Addison-Wesley, Reading, MA, 1994.

\bibitem{linusgit}
Linus Torvalds
\newblock \emph{Google Talk presentation on Git}

\bibitem{perforceclientspec}
Perforce documentation on ``Editing Client Specs''

\newblock \emph{
http://www.perforce.com/perforce/doc.current/manuals/p4web
/help/editclient.html
}

\end{thebibliography}

%----------------------------------------------------------------------

\end{document}
